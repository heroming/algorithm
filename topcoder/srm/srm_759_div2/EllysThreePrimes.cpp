#include <vector>
#include <list>
#include <set>
#include <map>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <string>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <ctime>
using namespace std;

#define px first
#define py second
#define pb push_back
#define mp make_pair
#define pque priority_queue
#define lowbit(x) ((x) & -(x))
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(), (v).end()
#define clr(v, e) memset(v, e, sizeof(v))
#define rep(it, v) for (auto it : v)
#define forn(i, n) for (int i = 0; i < (n); ++ i)
#define rforn(i, n) for (int i = (n) - 1; i >= 0; -- i)
#define form(i, a, b) for (int i = (a); i <= (b); ++ i)
#define rform(i, a, b) for (int i = (b); i >= (a); -- i)
#define forv(i, v) for (int i = 0; i < sz(v); ++ i)
#define iter(it, v) for (auto it = v.begin(); it != v.end(); ++ it)

typedef long long lint;
typedef vector<int> vint;
typedef vector<string> vstr;
typedef pair<int, int> pint;
typedef vector<lint> vlint;
typedef vector<pint> vpint;

class EllysThreePrimes {
public:
	vector <int> getPrimes(vector <int>);
};

const int B = 10;
const int N = 10000;
const int M = 100000;
const int maxn = 100010;

vint v, u;
bool f[maxn];

bool valid(int x, int y, int z, vint s) {
    if (z <= N || z >= M) return false;
    if (x == y || x == z || y == z) return false;

    int b0 = x % 10 + y % 10 + z % 10;
    if (s[0] != b0) return false;
    int b1 = x / 10 % 10 + y / 10 % 10 + z / 10 % 10;
    if (s[1] != b1) return false;
    int b2 = x / 100 % 10 + y / 100 % 10 + z / 100 % 10;
    if (s[2] != b2) return false;
    int b3 = x / 1000 % 10 + y / 1000 % 10 + z / 1000 % 10;
    if (s[3] != b3) return false;
    int b4 = x / 10000 % 10 + y / 10000 % 10 + z / 10000 % 10;
    if (s[4] != b4) return false;
    return true;
}

vector <int> EllysThreePrimes::getPrimes(vector <int> s) {
    if ((s[0] & 1) == 0) {
        return {};
    }

    v.clear();
    clr(f, 0);
    for (int i = 2; i < maxn; ++ i) {
        if (!f[i]) v.pb(i);
        for (int k = 0; k < sz(v) && i * v[k] < maxn; ++ k) {
            f[i * v[k]] = 1;
            if (i % v[k] == 0) break;
        }
    }

    forv (i, v) {
        int x = v[i];
        if (x > N && x < M) {
            u.pb(x);
        }
    }

    for (int i = 0; i < sz(u); ++ i) {
        for (int j = i + 1; j < sz(u); ++ j) {
            int x = u[i], y = u[j];

            int a = s[0] - x % 10 - y % 10;
            if (a < 0 || a >= B) continue;
            int b = s[1] - x / 10 % 10 - y / 10 % 10;
            if (b < 0 || b >= B) continue;
            int c = s[2] - x / 100 % 10 - y / 100 % 10;
            if (c < 0 || c >= B) continue;
            int d = s[3] - x / 1000 % 10 - y / 1000 % 10;
            if (d < 0 || d >= B) continue;
            int e = s[4] - x / 10000 % 10 - y / 10000 % 10;
            if (e < 0 || e >= B) continue;

            int z = e * 10000 + d * 1000 + c * 100 + b * 10 + a;
            if (z <= N || z >= M || x == z || y == z) continue;

            if (f[z] == 0) {
                return {x, y, z};
            }
        }
    }

    return {};
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, bool hasAnswer, vector <int> p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}";
	cout << "]" << endl;
	EllysThreePrimes *obj;
	vector <int> answer;
	obj = new EllysThreePrimes();
	clock_t startTime = clock();
	answer = obj->getPrimes(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(p1.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << p1[i];
		}
		cout << "}" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "{";
	for (int i = 0; int(answer.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << answer[i];
	}
	cout << "}" << endl;
	if (hasAnswer) {
		if (answer.size() != p1.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p1[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	vector <int> p0;
	vector <int> p1;

	{
	// ----- test 0 -----
	int t0[] = {19,12,15,11,14};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {20533,87119,44987};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 1 -----
	int t0[] = {22,19,3,8,23};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1.clear() /*{}*/;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 2 -----
	int t0[] = {13,17,0,25,20};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {27011,99083,99089};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 3 -----
	int t0[] = {11,12,13,14,15};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {47221,23789,94421};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 4 -----
	int t0[] = {14,27,6,12,15};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1.clear() /*{}*/;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// Kriss told Elly her three favorite five-digit prime numbers. Elly was lazy to remember them exactly, so she decided that she will write them below each other and she will only remember the sum of digits in each column. For example, if Kriss likes the primes 42649, 18287, and 91703, Elly will write them as follows:
// 
// 
//     42649
//     18287
//     91703
// 
// 
// Then, she will sum each column of digits separately, from the right to the left (i.e., starting with the ones digit of each number).
// In our example, the sums she will get are 9+7+3 = 19, 4+8+0 = 12, 6+2+7 = 15, 2+8+1 = 11, and 4+1+9 = 14.
// 
// 
// 
// Elly thought that it would be easy to reconstruct the numbers Kriss told her from the sums she remembers. It turns out that not only is it hard (since the answer can be ambiguous), but already finding any three distinct five-digit prime numbers that satisfy the conditions isn't trivial.
// 
// 
// 
// Now Elly has given you the five sums she remembers in the vector <int> sums, where sums[i] is the sum of digits that correspond to 10^i. Return a vector <int> with three elements - three distinct five-digit prime numbers, whose digits sum to the given numbers. If Elly didn't remember some of the numbers correctly and an answer doesn't exist, return an empty vector <int> instead.
// 
// 
// DEFINITION
// Class:EllysThreePrimes
// Method:getPrimes
// Parameters:vector <int>
// Returns:vector <int>
// Method signature:vector <int> getPrimes(vector <int> sums)
// 
// 
// NOTES
// -A prime number (or a prime) is a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers. (Wikipedia)
// -The five-digit primes cannot have leading zeros. For example, 00047 is not a five-digit prime.
// 
// 
// CONSTRAINTS
// -sums will contain exactly 5 elements.
// -Each element of sums will be between 0 and 27, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// {19, 12, 15, 11, 14}
// 
// Returns: {20533, 87119, 44987 }
// 
// You don't necessarily need to return the primes Kriss gave to Elly. You may return any three different ones that satisfy the conditions.
// 
// 1)
// {22, 19, 3, 8, 23}
// 
// Returns: { }
// 
// In this case Elly doesn't remember the sums properly, as there are no three different primes whose digits sum to these numbers.
// 
// 2)
// {13, 17, 0, 25, 20}
// 
// Returns: {27011, 99083, 99089 }
// 
// 
// 
// 3)
// {11, 12, 13, 14, 15}
// 
// Returns: {47221, 23789, 94421 }
// 
// 
// 
// 4)
// {14, 27, 6, 12, 15}
// 
// Returns: { }
// 
// No three five-digit primes have an even sum of the units digits.
// 
// END KAWIGIEDIT TESTING










//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
