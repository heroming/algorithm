#include <vector>
#include <list>
#include <set>
#include <map>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <string>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <ctime>
using namespace std;

#define px first
#define py second
#define pb push_back
#define mp make_pair
#define pque priority_queue
#define lowbit(x) ((x) & -(x))
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(), (v).end()
#define clr(v, e) memset(v, e, sizeof(v))
#define rep(it, v) for (auto it : v)
#define forn(i, n) for (int i = 0; i < (n); ++ i)
#define rforn(i, n) for (int i = (n) - 1; i >= 0; -- i)
#define form(i, a, b) for (int i = (a); i <= (b); ++ i)
#define rform(i, a, b) for (int i = (b); i >= (a); -- i)
#define forv(i, v) for (int i = 0; i < sz(v); ++ i)
#define iter(it, v) for (auto it = v.begin(); it != v.end(); ++ it)

typedef long long lint;
typedef vector<int> vint;
typedef vector<string> vstr;
typedef pair<int, int> pint;
typedef vector<lint> vlint;
typedef vector<pint> vpint;

class WildSequence {
public:
	vector <int> construct(int, vector <int>);
};

vector <int> WildSequence::construct(int h, vector <int> v) {
    vint s{h};
    int n = sz(v);
    if (n == 0) return s;

    sort(all(v));
    if (h > v[0]) {
        s.pb(v[0]);
        for (int i = 1; i < n; i += 2) {
            if (i + 1 < n) {
                s.pb(v[i + 1]);
            }
            s.pb(v[i]);
        }
    } else {
        for (int i = 0; i < n; i += 2) {
            if (i + 1 < n) {
                s.pb(v[i + 1]);
            }
            s.pb(v[i]);
        }
    }

    return s;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, vector <int> p1, bool hasAnswer, vector <int> p2) {
	cout << "Test " << testNum << ": [" << p0 << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}";
	cout << "]" << endl;
	WildSequence *obj;
	vector <int> answer;
	obj = new WildSequence();
	clock_t startTime = clock();
	answer = obj->construct(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(p2.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << p2[i];
		}
		cout << "}" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "{";
	for (int i = 0; int(answer.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << answer[i];
	}
	cout << "}" << endl;
	if (hasAnswer) {
		if (answer.size() != p2.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p2[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	int p0;
	vector <int> p1;
	vector <int> p2;

	{
	// ----- test 0 -----
	p0 = 20;
	int t1[] = {10,30};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {20,10,30};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 1 -----
	p0 = 20;
	int t1[] = {10,30,40};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {20,10,40,30};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 2 -----
	p0 = 4;
	int t1[] = {1,2,3,6,7,5};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {4,7,5,6,1,3,2};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// A sequence of distinct integers is called wild if it has the following properties:
// 
// 
// It never increases twice in a row.
// It never decreases twice in a row.
// 
// 
// For example, {4, 7, 3, 9, 1, 5, 2} is a wild sequence but {4, 7, 3, 6, 9, 1, 5, 2} is not, as it increases twice in a row: from 3 to 6 and then from 6 to 9.
// 
// 
// You are given the int head and the vector <int> rest.
// Construct any wild sequence that begins with head and continues with the elements of rest, in an order of your choice. You must use each element of rest exactly once and you cannot use any other numbers in your sequence.
// Return the answer as a vector <int>.
// Any valid wild sequence will be accepted.
// If there is no valid wild sequence, return an empty vector <int> instead.
// 
// 
// DEFINITION
// Class:WildSequence
// Method:construct
// Parameters:int, vector <int>
// Returns:vector <int>
// Method signature:vector <int> construct(int head, vector <int> rest)
// 
// 
// CONSTRAINTS
// -head will be between 0 and 10^6, inclusive.
// -rest will contain between 0 and 49 elements, inclusive.
// -Each element of rest will be between 0 and 10^6, inclusive.
// -The elements of rest will be distinct.
// -head will be distinct from all elements of rest.
// 
// 
// EXAMPLES
// 
// 0)
// 20
// {10, 30}
// 
// Returns: {20, 10, 30 }
// 
// Both {20, 10, 30} and {20, 30, 10} are correct answers. You may return either of them.
// 
// 1)
// 20
// {10, 30, 40}
// 
// Returns: {20, 10, 40, 30 }
// 
// This time, there are three correct answers: {20, 10, 40, 30}, {20, 30, 10, 40}, and {20, 40, 10, 30}. You may return any one of these sequences.
// 
// 2)
// 4
// {1, 2, 3, 6, 7, 5}
// 
// Returns: {4, 7, 5, 6, 1, 3, 2 }
// 
// 
// 
// END KAWIGIEDIT TESTING










//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
